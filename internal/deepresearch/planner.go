package deepresearch

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"briefly/internal/llm"
	"github.com/google/generative-ai-go/genai"
)

// LLMPlanner implements the Planner interface using an LLM
type LLMPlanner struct {
	llmClient *llm.Client
}

// NewLLMPlanner creates a new LLM-based planner
func NewLLMPlanner(llmClient *llm.Client) *LLMPlanner {
	return &LLMPlanner{
		llmClient: llmClient,
	}
}

// PlannerResponse represents the structured response from the planning LLM
type PlannerResponse struct {
	SubQueries []SubQuery `json:"sub_queries"`
	Reasoning  string     `json:"reasoning"`
}

// SubQuery represents a decomposed research question
type SubQuery struct {
	Query       string   `json:"query"`
	Rationale   string   `json:"rationale"`
	Keywords    []string `json:"keywords"`
	Priority    int      `json:"priority"` // 1-5, where 5 is highest priority
	SearchType  string   `json:"search_type"` // "recent", "academic", "general"
}

// DecomposeTopicSubQueries breaks down a broad topic into specific research questions
func (p *LLMPlanner) DecomposeTopicSubQueries(ctx context.Context, topic string) ([]string, error) {
	prompt := p.buildPlannerPrompt(topic)
	
	model := p.llmClient.GetGenaiModel()
	model.SetTemperature(0.3)
	model.SetTopP(0.9)
	model.SetMaxOutputTokens(2048)
	
	resp, err := model.GenerateContent(ctx, genai.Text(prompt))
	if err != nil {
		return nil, fmt.Errorf("failed to generate planning response: %w", err)
	}
	
	if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 {
		return nil, fmt.Errorf("no content generated by the API")
	}
	
	responsePart := resp.Candidates[0].Content.Parts[0]
	responseText, ok := responsePart.(genai.Text)
	if !ok {
		return nil, fmt.Errorf("unexpected response format from API, expected genai.Text")
	}
	
	response := string(responseText)

	// Clean the response by removing markdown code fences if present
	cleanedResponse := p.cleanJSONResponse(response)

	// Parse the JSON response
	var plannerResp PlannerResponse
	if err := json.Unmarshal([]byte(cleanedResponse), &plannerResp); err != nil {
		// Fallback: try to extract queries as plain text if JSON parsing fails
		queries := p.extractQueriesFromText(response)
		fmt.Printf("JSON parsing failed, extracted %d queries from text: %v\n", len(queries), queries)
		return queries, nil
	}

	// Extract just the query strings, sorted by priority
	queries := make([]string, 0, len(plannerResp.SubQueries))
	for i := 5; i >= 1; i-- { // Process highest priority first
		for _, sq := range plannerResp.SubQueries {
			if sq.Priority == i {
				queries = append(queries, sq.Query)
			}
		}
	}

	// Ensure we have at least some queries
	if len(queries) == 0 {
		return []string{topic}, nil // Fallback to original topic
	}

	// Limit to maximum of 7 queries as per requirements
	if len(queries) > 7 {
		queries = queries[:7]
	}

	fmt.Printf("Successfully generated %d research queries: %v\n", len(queries), queries)
	return queries, nil
}

// buildPlannerPrompt creates the prompt for topic decomposition
func (p *LLMPlanner) buildPlannerPrompt(topic string) string {
	return fmt.Sprintf(`You are a research planning assistant. Your task is to decompose a broad research topic into 3-7 specific, actionable sub-questions that will guide comprehensive research.

Topic: "%s"

Decompose this topic into sub-questions that:
1. Cover different aspects and perspectives of the topic
2. Are specific enough to yield focused search results  
3. Include both recent developments and foundational knowledge
4. Consider multiple viewpoints and potential controversies
5. Are searchable using web search engines

Respond with a JSON object in this exact format:
{
  "sub_queries": [
    {
      "query": "specific search query here",
      "rationale": "why this question is important for understanding the topic",
      "keywords": ["key", "terms", "for", "search"],
      "priority": 5,
      "search_type": "recent"
    }
  ],
  "reasoning": "overall strategy for researching this topic"
}

Guidelines:
- Priority: 1-5 (5 = highest priority, must research; 1 = nice to have)
- Search type: "recent" (last few weeks), "academic" (papers/studies), "general" (broader web)
- Aim for 4-6 sub-queries total
- Each query should be 3-15 words
- Include diverse perspectives and potential counterarguments
- Balance breadth and depth

Focus on creating queries that will find high-quality, authoritative sources.`, topic)
}

// extractQueriesFromText extracts search queries from plain text as a fallback
func (p *LLMPlanner) extractQueriesFromText(text string) []string {
	lines := strings.Split(text, "\n")
	var queries []string
	
	for _, line := range lines {
		line = strings.TrimSpace(line)
		
		// Look for JSON query fields and extract just the query content
		if strings.Contains(line, `"query":`) {
			// Extract text between quotes after "query":
			start := strings.Index(line, `"query":`)
			if start != -1 {
				remaining := line[start+8:] // Skip `"query":`
				remaining = strings.TrimSpace(remaining)
				if strings.HasPrefix(remaining, `"`) {
					// Find the closing quote
					end := strings.Index(remaining[1:], `"`)
					if end != -1 {
						query := remaining[1 : 1+end]
						if len(query) > 5 && len(query) < 200 { // Reasonable query length
							queries = append(queries, query)
						}
					}
				}
			}
			continue
		}
		
		// Skip JSON fragments and metadata lines
		if strings.Contains(line, `"keywords":`) || 
		   strings.Contains(line, `"rationale":`) ||
		   strings.Contains(line, `"priority":`) ||
		   strings.Contains(line, `"search_type":`) ||
		   strings.Contains(line, `":`) ||  // Any JSON key-value pair
		   strings.HasPrefix(line, `"`) && strings.HasSuffix(line, `",`) ||
		   strings.HasPrefix(line, `[`) || strings.HasSuffix(line, `]`) ||
		   strings.Contains(line, `"reasoning"`) {
			continue
		}
		
		// Look for lines that seem like questions or search queries (original logic)
		if len(line) > 10 && len(line) < 100 {
			// Remove common prefixes
			line = strings.TrimPrefix(line, "- ")
			line = strings.TrimPrefix(line, "* ")
			line = strings.TrimPrefix(line, "1. ")
			line = strings.TrimPrefix(line, "2. ")
			line = strings.TrimPrefix(line, "3. ")
			line = strings.TrimPrefix(line, "4. ")
			line = strings.TrimPrefix(line, "5. ")
			line = strings.TrimPrefix(line, "6. ")
			line = strings.TrimPrefix(line, "7. ")
			
			if strings.Contains(line, "?") || len(strings.Fields(line)) >= 3 {
				queries = append(queries, line)
			}
		}
	}
	
	// Limit to 7 queries max
	if len(queries) > 7 {
		queries = queries[:7]
	}
	
	return queries
}

// cleanJSONResponse removes markdown code fences and other formatting from LLM responses
func (p *LLMPlanner) cleanJSONResponse(response string) string {
	// Remove markdown code fences
	response = strings.TrimSpace(response)
	if strings.HasPrefix(response, "```json") {
		response = strings.TrimPrefix(response, "```json")
	}
	if strings.HasPrefix(response, "```") {
		response = strings.TrimPrefix(response, "```")
	}
	if strings.HasSuffix(response, "```") {
		response = strings.TrimSuffix(response, "```")
	}
	return strings.TrimSpace(response)
}